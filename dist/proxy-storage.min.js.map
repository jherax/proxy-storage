{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///proxy-storage.min.js","webpack:///webpack/bootstrap c9b7043ba837b106a41c","webpack:///./src/proxy-storage.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","initApi","api","prop","setProperty","initialize","obj","name","value","descriptor","configurable","enumerable","writable","Object","defineProperty","executeInterceptors","command","_len","arguments","length","args","Array","_key","_interceptors","forEach","action","checkEmpty","key","Error","isObject","prototype","toString","setTimestamp","options","undefined","opt","assign","d","date","Date","hours","setHours","getHours","days","setDate","getDate","months","setMonth","getMonth","years","setFullYear","getFullYear","buildExpirationString","expires","toUTCString","findCookie","cookie","nameEQ","trim","indexOf","cookieStorage","setItem","path","encodeURIComponent","$cookie","set","getItem","get","split","find","substring","decodeURIComponent","removeItem","clear","eq","indexEQ","index","memoryStorage","hashtable","getStoreFromWindow","setStoreToWindow","keys","store","JSON","parse","window","self","_typeof","e","stringify","isStorageAvailable","storageType","storageObj","_proxy","data","storageAvaliable","isAvaliable","configStorage","init","localStorage","sessionStorage","some","Symbol","iterator","constructor","_createClass","defineProperties","target","props","i","protoProps","staticProps","document","WebStorage","_this","hasOwnProperty","__storage__","_this2","push","storage","default"],"mappings":"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","file":"proxy-storage.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"proxyStorage\"] = factory();\n\telse\n\t\troot[\"proxyStorage\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"proxyStorage\"] = factory();\n\telse\n\t\troot[\"proxyStorage\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/* eslint-disable no-use-before-define, no-invalid-this */\n\t\n\t/**\n\t * This library uses an adapter that implements the Web Storage interface,\n\t * which is very useful to deal with the lack of compatibility between\n\t * document.cookie and localStorage and sessionStorage.\n\t *\n\t * It also provides a memoryStorage fallback that stores the data in memory\n\t * when all of above mechanisms are not available.\n\t *\n\t * Author: David Rivera\n\t * Github: https://github.com/jherax\n\t * License: \"MIT\"\n\t *\n\t * You can fork this project on github:\n\t * https://github.com/jherax/proxy-storage.git\n\t */\n\t\n\t// If you want to support all ES6 features, uncomment the next line\n\t// import 'babel-polyfill';\n\t\n\t/**\n\t * @private\n\t *\n\t * Proxy for the default cookie storage associated with the current document.\n\t *\n\t * @Reference\n\t * https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie\n\t *\n\t * @type {object}\n\t */\n\tvar $cookie = {\n\t  get: function get() {\n\t    return document.cookie;\n\t  },\n\t  set: function set(value) {\n\t    document.cookie = value;\n\t  }\n\t};\n\t\n\t/**\n\t * @private\n\t *\n\t * Proxy for Web Storage and Cookies.\n\t * All members implement the Web Storage interface.\n\t *\n\t * @Reference\n\t * https://developer.mozilla.org/en-US/docs/Web/API/Storage\n\t *\n\t * @type {object}\n\t */\n\tvar _proxy = {\n\t  localStorage: window.localStorage,\n\t  sessionStorage: window.sessionStorage,\n\t  cookieStorage: initApi(cookieStorage()),\n\t  memoryStorage: initApi(memoryStorage())\n\t};\n\t\n\t/**\n\t * @private\n\t *\n\t * Adds the current elements in the storage object\n\t *\n\t * @param  {object} api: the API to initialize\n\t * @return {object}\n\t */\n\tfunction initApi(api) {\n\t  // sets read-only and non-enumerable properties\n\t  for (var prop in api) {\n\t    // eslint-disable-line\n\t    if (prop !== 'initialize') setProperty(api, prop);\n\t  }\n\t  api.initialize();\n\t  // this method is removed after being invoked\n\t  // because is not part of the Web Storage interface\n\t  delete api.initialize;\n\t  return api;\n\t}\n\t\n\t/**\n\t * @private\n\t *\n\t * Creates a non-enumerable read-only property.\n\t *\n\t * @param  {object} obj: the object to add the property\n\t * @param  {string} name: the name of the property\n\t * @param  {any} value: the value of the property\n\t * @return {void}\n\t */\n\tfunction setProperty(obj, name, value) {\n\t  var descriptor = {\n\t    configurable: false,\n\t    enumerable: false,\n\t    writable: false\n\t  };\n\t  if (typeof value !== 'undefined') {\n\t    descriptor.value = value;\n\t  }\n\t  Object.defineProperty(obj, name, descriptor);\n\t}\n\t\n\t/**\n\t * @private\n\t *\n\t * Stores the interceptors for WebStorage methods\n\t *\n\t * @type {object}\n\t */\n\tvar _interceptors = {\n\t  setItem: [],\n\t  getItem: [],\n\t  removeItem: [],\n\t  clear: []\n\t};\n\t\n\t/**\n\t * @private\n\t *\n\t * Executes the interceptors of a WebStorage method\n\t *\n\t * @param  {string} command: name of the method to intercept\n\t * @return {void}\n\t */\n\tfunction executeInterceptors(command) {\n\t  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t    args[_key - 1] = arguments[_key];\n\t  }\n\t\n\t  _interceptors[command].forEach(function (action) {\n\t    return action.apply(undefined, args);\n\t  });\n\t}\n\t\n\t/**\n\t * @private\n\t *\n\t * Validates if the key is not empty.\n\t * (null, undefined or empty string)\n\t * @param  {string} key: keyname of the storage\n\t * @return {void}\n\t */\n\tfunction checkEmpty(key) {\n\t  if (key == null || key === '') {\n\t    throw new Error('The key provided can not be empty');\n\t  }\n\t}\n\t\n\t/**\n\t * @public\n\t *\n\t * Implementation of the Web Storage interface.\n\t * It saves and retrieves values as JSON.\n\t *\n\t * @Reference\n\t * https://developer.mozilla.org/en-US/docs/Web/API/Storage\n\t *\n\t * @type {Class}\n\t */\n\t\n\tvar WebStorage = function () {\n\t  /**\n\t   * Creates an instance of WebStorage.\n\t   *\n\t   * @param {string} storageType: it can be \"localStorage\", \"sessionStorage\", \"cookieStorage\", or \"memoryStorage\"\n\t   *\n\t   * @memberOf WebStorage\n\t   */\n\t  function WebStorage(storageType) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, WebStorage);\n\t\n\t    if (!_proxy.hasOwnProperty(storageType)) {\n\t      throw new Error('Storage type \"' + storageType + '\" is not valid');\n\t    }\n\t    setProperty(this, '__storage__', storageType);\n\t    // copies all existing elements in the storage\n\t    Object.keys(_proxy[storageType]).forEach(function (key) {\n\t      var value = _proxy[storageType][key];\n\t      try {\n\t        _this[key] = JSON.parse(value);\n\t      } catch (e) {\n\t        _this[key] = value;\n\t      }\n\t    });\n\t  }\n\t  /**\n\t   * Stores a value given a key name.\n\t   *\n\t   * @param  {string} key: keyname of the storage\n\t   * @param  {any} value: data to save in the storage\n\t   * @param  {object} options: additional options for cookieStorage\n\t   * @return {void}\n\t   *\n\t   * @memberOf WebStorage\n\t   */\n\t\n\t\n\t  _createClass(WebStorage, [{\n\t    key: 'setItem',\n\t    value: function setItem(key, value, options) {\n\t      checkEmpty(key);\n\t      this[key] = value;\n\t      executeInterceptors('setItem', key, value, options);\n\t      value = JSON.stringify(value);\n\t      _proxy[this.__storage__].setItem(key, value, options);\n\t    }\n\t    /**\n\t     * Retrieves a value by its key name.\n\t     *\n\t     * @param  {string} key: keyname of the storage\n\t     * @return {void}\n\t     *\n\t     * @memberOf WebStorage\n\t     */\n\t\n\t  }, {\n\t    key: 'getItem',\n\t    value: function getItem(key) {\n\t      checkEmpty(key);\n\t      executeInterceptors('getItem', key);\n\t      var value = _proxy[this.__storage__].getItem(key);\n\t      return JSON.parse(value);\n\t    }\n\t    /**\n\t     * Deletes a key from the storage.\n\t     *\n\t     * @param  {string} key: keyname of the storage\n\t     * @return {void}\n\t     *\n\t     * @memberOf WebStorage\n\t     */\n\t\n\t  }, {\n\t    key: 'removeItem',\n\t    value: function removeItem(key) {\n\t      checkEmpty(key);\n\t      delete this[key];\n\t      executeInterceptors('removeItem', key);\n\t      _proxy[this.__storage__].removeItem(key);\n\t    }\n\t    /**\n\t     * Removes all keys from the storage.\n\t     *\n\t     * @return {void}\n\t     *\n\t     * @memberOf WebStorage\n\t     */\n\t\n\t  }, {\n\t    key: 'clear',\n\t    value: function clear() {\n\t      var _this2 = this;\n\t\n\t      executeInterceptors('clear');\n\t      Object.keys(this).forEach(function (key) {\n\t        return delete _this2[key];\n\t      });\n\t      _proxy[this.__storage__].clear();\n\t    }\n\t    /**\n\t     * Gets the number of data items stored in the Storage object.\n\t     *\n\t     * @readonly\n\t     *\n\t     * @memberOf WebStorage\n\t     */\n\t\n\t  }, {\n\t    key: 'length',\n\t    get: function get() {\n\t      return Object.keys(this).length;\n\t    }\n\t    /**\n\t     * Adds an interceptor to a WebStorage method\n\t     *\n\t     * @param  {string} command: name of the API method to intercept\n\t     * @param  {function} action: callback executed when the API method is called\n\t     * @return {void}\n\t     *\n\t     * @memberOf WebStorage\n\t     */\n\t\n\t  }], [{\n\t    key: 'interceptors',\n\t    value: function interceptors(command, action) {\n\t      if (command in _interceptors && typeof action === 'function') _interceptors[command].push(action);\n\t    }\n\t  }]);\n\t\n\t  return WebStorage;\n\t}();\n\t\n\t/**\n\t * @public\n\t *\n\t * Determines which storage mechanisms are available.\n\t *\n\t * @type {object}\n\t */\n\t\n\t\n\tvar isAvaliable = {\n\t  localStorage: false,\n\t  sessionStorage: false,\n\t  cookieStorage: false,\n\t  memoryStorage: true\n\t};\n\t\n\t/**\n\t * @public\n\t *\n\t * Current storage mechanism.\n\t * @type {object}\n\t */\n\tvar storage = null;\n\t\n\t/**\n\t * @public\n\t *\n\t * Get/Set the storage mechanism to use by default.\n\t * @type {object}\n\t */\n\tvar configStorage = {\n\t  get: function get() {\n\t    return storage.__storage__;\n\t  },\n\t\n\t\n\t  /**\n\t   * Sets the storage mechanism to use by default.\n\t   * @param  {string} storageType: it can be \"localStorage\", \"sessionStorage\", \"cookieStorage\", or \"memoryStorage\"\n\t   * @return {void}\n\t   */\n\t  set: function set(storageType) {\n\t    if (!_proxy.hasOwnProperty(storageType)) {\n\t      throw new Error('Storage type \"' + storageType + '\" is not valid');\n\t    }\n\t    exports.default = storage = new WebStorage(storageType);\n\t  }\n\t};\n\t\n\t/**\n\t * @private\n\t *\n\t * Determines whether a value is a plain object\n\t *\n\t * @param  {any} value: the object to test\n\t * @return {boolean}\n\t */\n\tfunction isObject(value) {\n\t  return Object.prototype.toString.call(value) === '[object Object]';\n\t}\n\t\n\t/**\n\t * @private\n\t *\n\t * Allows add or subtract timestamps to the current date or to a specific date.\n\t * @param  {object} options: It contains the timestamps to add or remove to the date, and have the following properties:\n\t *         - {Date} date: if provided, the timestamps will affect this date, otherwise a new current date will be used.\n\t *         - {number} hours: hours to add/subtract\n\t *         - {number} days: days to add/subtract\n\t *         - {number} months: months to add/subtract\n\t *         - {number} years: years to add/subtract\n\t * @return {Date}\n\t */\n\tfunction setTimestamp() {\n\t  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\n\t  var opt = Object.assign({}, options);\n\t  var d = opt.date instanceof Date ? opt.date : new Date();\n\t  if (+opt.hours) d.setHours(d.getHours() + opt.hours);\n\t  if (+opt.days) d.setDate(d.getDate() + opt.days);\n\t  if (+opt.months) d.setMonth(d.getMonth() + opt.months);\n\t  if (+opt.years) d.setFullYear(d.getFullYear() + opt.years);\n\t  return d;\n\t}\n\t\n\t/**\n\t * @private\n\t *\n\t * Builds the expiration part for the cookie\n\t *\n\t * @param  {Date|object} date: the expiration date. See `setTimestamp(options)`\n\t * @return {string}\n\t */\n\tfunction buildExpirationString(date) {\n\t  var expires = date instanceof Date ? setTimestamp({ date: date }) : setTimestamp(date);\n\t  return '; expires=' + expires.toUTCString();\n\t}\n\t\n\t/**\n\t * @private\n\t *\n\t * Callback that finds an element in the array.\n\t * @param  {string} cookie: key=value\n\t * @return {boolean}\n\t */\n\tfunction findCookie(cookie) {\n\t  var nameEQ = this.toString();\n\t  // prevent leading spaces before the key\n\t  return cookie.trim().indexOf(nameEQ) === 0;\n\t}\n\t\n\t/**\n\t * @private\n\t *\n\t * Manages actions for creation/reading/deleting cookies.\n\t * Implements Web Storage interface methods.\n\t *\n\t * @return {object}\n\t */\n\tfunction cookieStorage() {\n\t  var api = {\n\t    setItem: function setItem(key, value, options) {\n\t      var expires = '',\n\t          cookie = void 0;\n\t      options = Object.assign({ path: '/' }, options);\n\t      if (isObject(options.expires) || options.expires instanceof Date) {\n\t        expires = buildExpirationString(options.expires);\n\t      }\n\t      cookie = key + '=' + encodeURIComponent(value) + expires + '; path=' + options.path;\n\t      $cookie.set(cookie);\n\t    },\n\t    getItem: function getItem(key) {\n\t      var value = void 0;\n\t      var nameEQ = key + '=';\n\t      var cookie = $cookie.get().split(';').find(findCookie, nameEQ);\n\t      if (cookie) {\n\t        // prevent leading spaces before the key name\n\t        value = cookie.trim().substring(nameEQ.length, cookie.length);\n\t        value = decodeURIComponent(value);\n\t      }\n\t      return value;\n\t    },\n\t    removeItem: function removeItem(key) {\n\t      api.setItem(key, '', { expires: { days: -1 } });\n\t    },\n\t    clear: function clear() {\n\t      var eq = '=';\n\t      var indexEQ = void 0,\n\t          key = void 0;\n\t      $cookie.get().split(';').forEach(function (cookie) {\n\t        indexEQ = cookie.indexOf(eq);\n\t        if (indexEQ > -1) {\n\t          key = cookie.substring(0, indexEQ);\n\t          // prevent leading spaces before the key\n\t          api.removeItem(key.trim());\n\t        }\n\t      });\n\t    },\n\t    initialize: function initialize() {\n\t      $cookie.get().split(';').forEach(function (cookie) {\n\t        var index = cookie.indexOf('=');\n\t        var key = cookie.substring(0, index).trim();\n\t        var value = cookie.substring(index + 1).trim();\n\t        api[key] = decodeURIComponent(value);\n\t      });\n\t    }\n\t  };\n\t  return api;\n\t}\n\t\n\t/**\n\t * @private\n\t *\n\t * Manages actions for creation/reading/deleting data in memory.\n\t * Implements Web Storage interface methods.\n\t * It also adds a hack to persist the store as a session in the current window.\n\t *\n\t * @return {object}\n\t */\n\tfunction memoryStorage() {\n\t  var hashtable = getStoreFromWindow();\n\t  var api = {\n\t    setItem: function setItem(key, value) {\n\t      hashtable[key] = value;\n\t      setStoreToWindow(hashtable);\n\t    },\n\t    getItem: function getItem(key) {\n\t      return hashtable[key];\n\t    },\n\t    removeItem: function removeItem(key) {\n\t      delete hashtable[key];\n\t      setStoreToWindow(hashtable);\n\t    },\n\t    clear: function clear() {\n\t      Object.keys(hashtable).forEach(function (key) {\n\t        return delete hashtable[key];\n\t      });\n\t      setStoreToWindow(hashtable);\n\t    },\n\t    initialize: function initialize() {\n\t      Object.assign(api, hashtable);\n\t    }\n\t  };\n\t  return api;\n\t}\n\t\n\t/**\n\t * @private\n\t *\n\t * Gets the hashtable-store from the current window.\n\t * @return {object}\n\t */\n\tfunction getStoreFromWindow() {\n\t  try {\n\t    var store = JSON.parse(window.self.name);\n\t    if (store && (typeof store === 'undefined' ? 'undefined' : _typeof(store)) === 'object') return store;\n\t  } catch (e) {\n\t    return {};\n\t  }\n\t}\n\t\n\t/**\n\t * @private\n\t *\n\t * Saves the hashtable-store in the current window.\n\t * @param  {object} hashtable: {key,value} pairs stored in memoryStorage\n\t * @return {void}\n\t */\n\tfunction setStoreToWindow(hashtable) {\n\t  var store = JSON.stringify(hashtable);\n\t  window.self.name = store;\n\t}\n\t\n\t/**\n\t * @private\n\t *\n\t * Checks whether a storage mechanism is available.\n\t * @param  {string} storageType: it can be \"localStorage\", \"sessionStorage\", \"cookieStorage\", or \"memoryStorage\"\n\t * @return {boolean}\n\t */\n\tfunction isStorageAvailable(storageType) {\n\t  var storageObj = _proxy[storageType];\n\t  var data = '__proxy-storage__';\n\t  try {\n\t    storageObj.setItem(data, data);\n\t    storageObj.removeItem(data);\n\t    return true;\n\t  } catch (e) {\n\t    return false;\n\t  }\n\t}\n\t\n\t/**\n\t * @private\n\t *\n\t * Sets the default storage mechanism available.\n\t * @param  {string} storageType: it can be \"localStorage\", \"sessionStorage\", \"cookieStorage\", or \"memoryStorage\"\n\t * @return {boolean}\n\t */\n\tfunction storageAvaliable(storageType) {\n\t  if (isAvaliable[storageType]) {\n\t    configStorage.set(storageType);\n\t  }\n\t  return isAvaliable[storageType];\n\t}\n\t\n\t/**\n\t * @private\n\t *\n\t * Initializes the module.\n\t * @return {void}\n\t */\n\tfunction init() {\n\t  isAvaliable.localStorage = isStorageAvailable('localStorage');\n\t  isAvaliable.sessionStorage = isStorageAvailable('sessionStorage');\n\t  isAvaliable.cookieStorage = isStorageAvailable('cookieStorage');\n\t  // sets the default storage mechanism available\n\t  Object.keys(isAvaliable).some(storageAvaliable);\n\t}\n\t\n\tinit();\n\t\n\t// @public API\n\texports.default = storage;\n\texports.WebStorage = WebStorage;\n\texports.configStorage = configStorage;\n\texports.isAvaliable = isAvaliable;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// proxy-storage.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c9b7043ba837b106a41c","/* eslint-disable no-use-before-define, no-invalid-this */\n\n/**\n * This library uses an adapter that implements the Web Storage interface,\n * which is very useful to deal with the lack of compatibility between\n * document.cookie and localStorage and sessionStorage.\n *\n * It also provides a memoryStorage fallback that stores the data in memory\n * when all of above mechanisms are not available.\n *\n * Author: David Rivera\n * Github: https://github.com/jherax\n * License: \"MIT\"\n *\n * You can fork this project on github:\n * https://github.com/jherax/proxy-storage.git\n */\n\n// If you want to support all ES6 features, uncomment the next line\n// import 'babel-polyfill';\n\n/**\n * @private\n *\n * Proxy for the default cookie storage associated with the current document.\n *\n * @Reference\n * https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie\n *\n * @type {object}\n */\nconst $cookie = {\n  get: () => document.cookie,\n  set: (value) => {\n    document.cookie = value;\n  },\n};\n\n/**\n * @private\n *\n * Proxy for Web Storage and Cookies.\n * All members implement the Web Storage interface.\n *\n * @Reference\n * https://developer.mozilla.org/en-US/docs/Web/API/Storage\n *\n * @type {object}\n */\nconst _proxy = {\n  localStorage: window.localStorage,\n  sessionStorage: window.sessionStorage,\n  cookieStorage: initApi(cookieStorage()),\n  memoryStorage: initApi(memoryStorage()),\n};\n\n/**\n * @private\n *\n * Adds the current elements in the storage object\n *\n * @param  {object} api: the API to initialize\n * @return {object}\n */\nfunction initApi(api) {\n  // sets read-only and non-enumerable properties\n  for (let prop in api) { // eslint-disable-line\n    if (prop !== 'initialize')\n      setProperty(api, prop);\n  }\n  api.initialize();\n  // this method is removed after being invoked\n  // because is not part of the Web Storage interface\n  delete api.initialize;\n  return api;\n}\n\n/**\n * @private\n *\n * Creates a non-enumerable read-only property.\n *\n * @param  {object} obj: the object to add the property\n * @param  {string} name: the name of the property\n * @param  {any} value: the value of the property\n * @return {void}\n */\nfunction setProperty(obj, name, value) {\n  let descriptor = {\n    configurable: false,\n    enumerable: false,\n    writable: false,\n  };\n  if (typeof value !== 'undefined') {\n    descriptor.value = value;\n  }\n  Object.defineProperty(obj, name, descriptor);\n}\n\n/**\n * @private\n *\n * Stores the interceptors for WebStorage methods\n *\n * @type {object}\n */\nconst _interceptors = {\n  setItem: [],\n  getItem: [],\n  removeItem: [],\n  clear: [],\n};\n\n/**\n * @private\n *\n * Executes the interceptors of a WebStorage method\n *\n * @param  {string} command: name of the method to intercept\n * @return {void}\n */\nfunction executeInterceptors(command, ...args) {\n  _interceptors[command].forEach((action) => action(...args));\n}\n\n/**\n * @private\n *\n * Validates if the key is not empty.\n * (null, undefined or empty string)\n * @param  {string} key: keyname of the storage\n * @return {void}\n */\nfunction checkEmpty(key) {\n  if (key == null || key === '') {\n    throw new Error('The key provided can not be empty');\n  }\n}\n\n/**\n * @public\n *\n * Implementation of the Web Storage interface.\n * It saves and retrieves values as JSON.\n *\n * @Reference\n * https://developer.mozilla.org/en-US/docs/Web/API/Storage\n *\n * @type {Class}\n */\nclass WebStorage {\n  /**\n   * Creates an instance of WebStorage.\n   *\n   * @param {string} storageType: it can be \"localStorage\", \"sessionStorage\", \"cookieStorage\", or \"memoryStorage\"\n   *\n   * @memberOf WebStorage\n   */\n  constructor(storageType) {\n    if (!_proxy.hasOwnProperty(storageType)) {\n      throw new Error(`Storage type \"${storageType}\" is not valid`);\n    }\n    setProperty(this, '__storage__', storageType);\n    // copies all existing elements in the storage\n    Object.keys(_proxy[storageType]).forEach((key) => {\n      let value = _proxy[storageType][key];\n      try {\n        this[key] = JSON.parse(value);\n      } catch (e) {\n        this[key] = value;\n      }\n    });\n  }\n  /**\n   * Stores a value given a key name.\n   *\n   * @param  {string} key: keyname of the storage\n   * @param  {any} value: data to save in the storage\n   * @param  {object} options: additional options for cookieStorage\n   * @return {void}\n   *\n   * @memberOf WebStorage\n   */\n  setItem(key, value, options) {\n    checkEmpty(key);\n    this[key] = value;\n    executeInterceptors('setItem', key, value, options);\n    value = JSON.stringify(value);\n    _proxy[this.__storage__].setItem(key, value, options);\n  }\n  /**\n   * Retrieves a value by its key name.\n   *\n   * @param  {string} key: keyname of the storage\n   * @return {void}\n   *\n   * @memberOf WebStorage\n   */\n  getItem(key) {\n    checkEmpty(key);\n    executeInterceptors('getItem', key);\n    const value = _proxy[this.__storage__].getItem(key);\n    return JSON.parse(value);\n  }\n  /**\n   * Deletes a key from the storage.\n   *\n   * @param  {string} key: keyname of the storage\n   * @return {void}\n   *\n   * @memberOf WebStorage\n   */\n  removeItem(key) {\n    checkEmpty(key);\n    delete this[key];\n    executeInterceptors('removeItem', key);\n    _proxy[this.__storage__].removeItem(key);\n  }\n  /**\n   * Removes all keys from the storage.\n   *\n   * @return {void}\n   *\n   * @memberOf WebStorage\n   */\n  clear() {\n    executeInterceptors('clear');\n    Object.keys(this).forEach((key) => delete this[key]);\n    _proxy[this.__storage__].clear();\n  }\n  /**\n   * Gets the number of data items stored in the Storage object.\n   *\n   * @readonly\n   *\n   * @memberOf WebStorage\n   */\n  get length() {\n    return Object.keys(this).length;\n  }\n  /**\n   * Adds an interceptor to a WebStorage method\n   *\n   * @param  {string} command: name of the API method to intercept\n   * @param  {function} action: callback executed when the API method is called\n   * @return {void}\n   *\n   * @memberOf WebStorage\n   */\n  static interceptors(command, action) {\n    if (command in _interceptors && typeof action === 'function')\n      _interceptors[command].push(action);\n  }\n}\n\n/**\n * @public\n *\n * Determines which storage mechanisms are available.\n *\n * @type {object}\n */\nconst isAvaliable = {\n  localStorage: false,\n  sessionStorage: false,\n  cookieStorage: false,\n  memoryStorage: true,\n};\n\n/**\n * @public\n *\n * Current storage mechanism.\n * @type {object}\n */\nlet storage = null;\n\n/**\n * @public\n *\n * Get/Set the storage mechanism to use by default.\n * @type {object}\n */\nconst configStorage = {\n  get() {\n    return storage.__storage__;\n  },\n\n  /**\n   * Sets the storage mechanism to use by default.\n   * @param  {string} storageType: it can be \"localStorage\", \"sessionStorage\", \"cookieStorage\", or \"memoryStorage\"\n   * @return {void}\n   */\n  set(storageType) {\n    if (!_proxy.hasOwnProperty(storageType)) {\n      throw new Error(`Storage type \"${storageType}\" is not valid`);\n    }\n    storage = new WebStorage(storageType);\n  },\n};\n\n/**\n * @private\n *\n * Determines whether a value is a plain object\n *\n * @param  {any} value: the object to test\n * @return {boolean}\n */\nfunction isObject(value) {\n  return Object.prototype.toString.call(value) === '[object Object]';\n}\n\n/**\n * @private\n *\n * Allows add or subtract timestamps to the current date or to a specific date.\n * @param  {object} options: It contains the timestamps to add or remove to the date, and have the following properties:\n *         - {Date} date: if provided, the timestamps will affect this date, otherwise a new current date will be used.\n *         - {number} hours: hours to add/subtract\n *         - {number} days: days to add/subtract\n *         - {number} months: months to add/subtract\n *         - {number} years: years to add/subtract\n * @return {Date}\n */\nfunction setTimestamp(options = {}) {\n  const opt = Object.assign({}, options);\n  let d = opt.date instanceof Date ? opt.date : new Date();\n  if (+opt.hours) d.setHours(d.getHours() + opt.hours);\n  if (+opt.days) d.setDate(d.getDate() + opt.days);\n  if (+opt.months) d.setMonth(d.getMonth() + opt.months);\n  if (+opt.years) d.setFullYear(d.getFullYear() + opt.years);\n  return d;\n}\n\n/**\n * @private\n *\n * Builds the expiration part for the cookie\n *\n * @param  {Date|object} date: the expiration date. See `setTimestamp(options)`\n * @return {string}\n */\nfunction buildExpirationString(date) {\n  let expires = (date instanceof Date ?\n    setTimestamp({date}) :\n    setTimestamp(date)\n  );\n  return `; expires=${expires.toUTCString()}`;\n}\n\n/**\n * @private\n *\n * Callback that finds an element in the array.\n * @param  {string} cookie: key=value\n * @return {boolean}\n */\nfunction findCookie(cookie) {\n  const nameEQ = this.toString();\n  // prevent leading spaces before the key\n  return cookie.trim().indexOf(nameEQ) === 0;\n}\n\n/**\n * @private\n *\n * Manages actions for creation/reading/deleting cookies.\n * Implements Web Storage interface methods.\n *\n * @return {object}\n */\nfunction cookieStorage() {\n  const api = {\n    setItem(key, value, options) {\n      let expires = '', cookie;\n      options = Object.assign({path: '/'}, options);\n      if (isObject(options.expires) || options.expires instanceof Date) {\n        expires = buildExpirationString(options.expires);\n      }\n      cookie = `${key}=${encodeURIComponent(value)}${expires}; path=${options.path}`;\n      $cookie.set(cookie);\n    },\n\n    getItem(key) {\n      let value = void 0;\n      const nameEQ = `${key}=`;\n      const cookie = $cookie.get().split(';').find(findCookie, nameEQ);\n      if (cookie) {\n        // prevent leading spaces before the key name\n        value = cookie.trim().substring(nameEQ.length, cookie.length);\n        value = decodeURIComponent(value);\n      }\n      return value;\n    },\n\n    removeItem(key) {\n      api.setItem(key, '', {expires: {days: -1}});\n    },\n\n    clear() {\n      const eq = '=';\n      let indexEQ, key;\n      $cookie.get().split(';').forEach((cookie) => {\n        indexEQ = cookie.indexOf(eq);\n        if (indexEQ > -1) {\n          key = cookie.substring(0, indexEQ);\n          // prevent leading spaces before the key\n          api.removeItem(key.trim());\n        }\n      });\n    },\n\n    initialize() {\n      $cookie.get().split(';').forEach((cookie) => {\n        const index = cookie.indexOf('=');\n        const key = cookie.substring(0, index).trim();\n        const value = cookie.substring(index + 1).trim();\n        api[key] = decodeURIComponent(value);\n      });\n    },\n  };\n  return api;\n}\n\n/**\n * @private\n *\n * Manages actions for creation/reading/deleting data in memory.\n * Implements Web Storage interface methods.\n * It also adds a hack to persist the store as a session in the current window.\n *\n * @return {object}\n */\nfunction memoryStorage() {\n  const hashtable = getStoreFromWindow();\n  const api = {\n    setItem(key, value) {\n      hashtable[key] = value;\n      setStoreToWindow(hashtable);\n    },\n    getItem(key) {\n      return hashtable[key];\n    },\n    removeItem(key) {\n      delete hashtable[key];\n      setStoreToWindow(hashtable);\n    },\n    clear() {\n      Object.keys(hashtable).forEach((key) => delete hashtable[key]);\n      setStoreToWindow(hashtable);\n    },\n    initialize() {\n      Object.assign(api, hashtable);\n    },\n  };\n  return api;\n}\n\n/**\n * @private\n *\n * Gets the hashtable-store from the current window.\n * @return {object}\n */\nfunction getStoreFromWindow() {\n  try {\n    const store = JSON.parse(window.self.name);\n    if (store && typeof store === 'object') return store;\n  } catch (e) {\n    return {};\n  }\n}\n\n/**\n * @private\n *\n * Saves the hashtable-store in the current window.\n * @param  {object} hashtable: {key,value} pairs stored in memoryStorage\n * @return {void}\n */\nfunction setStoreToWindow(hashtable) {\n  const store = JSON.stringify(hashtable);\n  window.self.name = store;\n}\n\n/**\n * @private\n *\n * Checks whether a storage mechanism is available.\n * @param  {string} storageType: it can be \"localStorage\", \"sessionStorage\", \"cookieStorage\", or \"memoryStorage\"\n * @return {boolean}\n */\nfunction isStorageAvailable(storageType) {\n  const storageObj = _proxy[storageType];\n  const data = '__proxy-storage__';\n  try {\n    storageObj.setItem(data, data);\n    storageObj.removeItem(data);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * @private\n *\n * Sets the default storage mechanism available.\n * @param  {string} storageType: it can be \"localStorage\", \"sessionStorage\", \"cookieStorage\", or \"memoryStorage\"\n * @return {boolean}\n */\nfunction storageAvaliable(storageType) {\n  if (isAvaliable[storageType]) {\n    configStorage.set(storageType);\n  }\n  return isAvaliable[storageType];\n}\n\n/**\n * @private\n *\n * Initializes the module.\n * @return {void}\n */\nfunction init() {\n  isAvaliable.localStorage = isStorageAvailable('localStorage');\n  isAvaliable.sessionStorage = isStorageAvailable('sessionStorage');\n  isAvaliable.cookieStorage = isStorageAvailable('cookieStorage');\n  // sets the default storage mechanism available\n  Object.keys(isAvaliable).some(storageAvaliable);\n}\n\ninit();\n\n// @public API\nexport {storage as default, WebStorage, configStorage, isAvaliable};\n\n\n\n// WEBPACK FOOTER //\n// ./src/proxy-storage.js"],"sourceRoot":""}